{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence Protocols","text":"<p>Qadence Protocols is a collection of features to enhance Qadence inputs and outputs for error mitigation and measurements.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li>A collection of readout error mitigation protocols.</li> <li>A collection of measurement handling protocols when computing expectation values.</li> </ul>"},{"location":"#pre-requisites","title":"Pre-requisites","text":"<p>The library uses the following tools:</p> <ul> <li>hatch for managing virtual environment and dependencies</li> <li>pytest for building the unit tests suite</li> <li>black, isort and flake8 for code formatting and linting</li> <li>mypy for static type checking</li> <li>pre-commit for applying linting and formatting automatically before committing new code</li> </ul> <p>We recommend to use <code>pyenv</code> for managing python versions for managing python versions both globally and locally:</p> <pre><code># System-wide install of a python version.\npyenv install 3.10\n\n# Use 3.10 everywhere.\npyenv global 3.10\n\n# Or locally in the current directory.\npyenv local 3.10\n</code></pre>"},{"location":"#install-from-pypi","title":"Install from PyPi","text":"<p><code>qadence-protocols</code> is available on PyPi through <code>pip</code>.</p> <pre><code>pip install qadence-protocols\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>All Pasqal quantum libraries require Python &gt;=3.8. For development, the preferred method to install this package is to use <code>hatch</code>. You can install from source by cloning this repository and run:</p> <pre><code>python -m pip install hatch\npython -m hatch -v shell\n\n# execute any script using the library\npython my_script.py\n</code></pre> <p>Alternatively, you can also:</p> <ul> <li>install with <code>pip</code> in development mode by simply running <code>pip install -e .</code>. Notice that in this way   you will install all the dependencies, including extras.</li> <li>install it with <code>conda</code> by simply using <code>pip</code> inside the Conda environment.</li> </ul>"},{"location":"#develop","title":"Develop","text":"<p>When developing the package, the recommended way is to create a virtual environment with <code>hatch</code> as shown above:</p> <pre><code>python -m pip install hatch\npython -m hatch -v shell\n</code></pre> <p>When inside the shell with development dependencies, install first the pre-commit hook: <pre><code>pre-commit install\n</code></pre></p> <p>In this way, you will get automatic linting and formatting every time you commit new code. Do not forget to run the unit test suite by simply running the <code>pytest</code> command.</p> <p>If you do not want to get into the Hatch shell, you can alternatively do the following:</p> <pre><code>python -m pip install hatch\npython -m hatch -v shell\n\n# install the pre-commit\npython -m hatch run pre-commit install\n\n# commit some code\npython -m hatch run git commit -m \"My awesome commit\"\n\n# run the unit tests suite\npython -m hatch run pytest\n</code></pre>"},{"location":"#document","title":"Document","text":"<p>You can improve the documentation of the package by editing this file for the landing page or adding new markdown or Jupyter notebooks to the <code>docs/</code> folder in the root of the project. In order to modify the table of contents, edit the <code>mkdocs.yml</code> file in the root of the project.</p> <p>In order to build and serve the documentation locally, you can use <code>hatch</code> with the right environment:</p> <pre><code>python -m hatch -v run docs:build\npython -m hatch -v run docs:serve\n</code></pre> <p>If you don't want to use <code>hatch</code>, just check into your favorite virtual environment and execute the following commands:</p> <pre><code>python -m pip install -r docs/requirements.txt\nmkdocs build\nmkdocs serve\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"CODE OF CONDUCT","text":"<p>Code of Conduct</p>"},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence-Protocols. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence_protocols's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence-Protocols. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence-protocols</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence-protocols.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence-protocols.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"getting_started/","title":"Getting started","text":"<p>This is just a sample notebook to showcase the rendering of Jupyter notebooks in the documentation.</p> In\u00a0[1]: Copied! <pre>from qadence_protocol import *\n\nprint(\"Hello, world!\")\n</pre> from qadence_protocol import *  print(\"Hello, world!\") <pre>Pasqal template Python project\n</pre>"},{"location":"contents/","title":"Contents","text":""},{"location":"contents/#class-description-todo","title":"Class description (TODO)","text":""},{"location":"error_mitigation/","title":"Error Mitigation","text":"<p>Errors may show up in various forms when trying to extract information from a quantum circuit. These include coherent and incoherent errors that effect gate execution, readout error during measurement and statistical errors.</p> <ul> <li>Incoherent errors are modelled through noisy channels, i.e. depolarizing, dephazing and erasure.</li> <li>Coherent errors are modelled as parameteric noise sampled from a distribution that shifts the operation to be performed.</li> <li>Measurement errors are introduced as bitflip operators that occur in the computational basis modelled using a confusion matrix.</li> <li>Statistical noises are introduced through finite sampling</li> </ul>"},{"location":"error_mitigation/#incoherent-errors","title":"Incoherent errors","text":""},{"location":"error_mitigation/#digital-errors","title":"Digital errors","text":"<p>Errors here are modelled to be executed at the end of each gate execution. The errors might be local or global. Global errors cannot be factorized as tensor products of independent channels. Implementation of digital errors is now supported on PyQ</p>"},{"location":"error_mitigation/#analog-errors","title":"Analog errors","text":"<p>Errors are incorporated as a part of the open system dynamics coupled with the effects of environment showing up as Krauss operators. The dynamics of an open quantum system happens through the Linbladian equation defined for markovian systems (memoryless systems). Its given by</p> \\[     \\frac{d\\rho}{dt} = L[\\rho] = -i[H,\\rho] + \\sum \\gamma_i \\bigg(L_i\\rho L_i^{\\dagger} - \\frac{1}{2} \\{L_i^{\\dagger}L_i,\\rho\\}\\bigg) \\] <p>We use qutip <code>mesolve</code> for the computation as a Pulser backend invoked for analog circuits written in Qadence. Qadence Protocols offers a number of noise mitigation techniques to achieve better accuracy of simulation outputs. Currently supported methods mitigate primarily measurement readout errors. For analog blocks we support mitigating depolarizing and dephasing noise via Zero Noise Extrapolation.</p>"},{"location":"error_mitigation/incoherent_error_mitigation/","title":"Incoherent error mitigation","text":""},{"location":"error_mitigation/incoherent_error_mitigation/#zero-noise-extrapolation-for-analog-blocks","title":"Zero-noise extrapolation for analog blocks","text":"<p>Zero-noise extrapolation (ZNE) is an error mitigation technique in which the expectation value computed at different noise levels is extrapolated to the zero noise limit (ideal expectation) using a class of functions. In digital computing, this is typically implemented by \"folding\" the circuit at a local (involves inverting gates locally) or global level (involves inverting blocks of gates). This allows to artificially increase the noise levels by integer folds<sup>1</sup>. In the analog ZNE variation, analog blocks are time stretched to again artificially increase in noise<sup>1</sup>. Using ZNE on neutral atoms would require stretching the register to scale the interaction hamiltonian appropriately.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, chain, AnalogRX, AnalogRZ, PI, BackendName, DiffMode, Z\nimport numpy as np\n\n\nanalog_block = chain(AnalogRX(PI / 2.0), AnalogRZ(PI))\nobservable = [Z(0) + Z(1)]\ncircuit = QuantumCircuit(2, analog_block)\nmodel_noiseless = QuantumModel(\n    circuit=circuit, observable=observable, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR\n)\n</code></pre> <pre><code>noiseless_expectation = tensor([[0.3961]])\n</code></pre> <pre><code>from qadence import NoiseProtocol, NoiseHandler\nfrom qadence_protocols import Mitigations\nimport torch\n\nnoise = NoiseHandler(protocol=NoiseProtocol.ANALOG.DEPOLARIZING, options={\"noise_probs\": [0.2]})\nmodel = QuantumModel(\n    circuit=circuit, observable=observable, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR\n)\n\nfor data_points in [2,5]:\n    options = {\"stretches\": torch.linspace(1, 3, data_points)}\n    mitigate = Mitigations(protocol=Mitigations.ANALOG_ZNE, options=options)\n\n    mitigated_expectation = mitigate(model=model, noise=noise)\n</code></pre> <pre><code>noiseless_expectation with 2 data points tensor([0.3827])\nnoiseless_expectation with 5 data points tensor([0.3988])\n</code></pre>"},{"location":"error_mitigation/incoherent_error_mitigation/#references","title":"References","text":"<ol> <li> <p>Mitiq: What's the theory behind ZNE? \u21a9\u21a9</p> </li> </ol>"},{"location":"error_mitigation/readout_mitigation/","title":"Readout mitigation","text":""},{"location":"error_mitigation/readout_mitigation/#readout-error-mitigation","title":"Readout error mitigation","text":"<p>Readout errors are introduced during measurements in the computation basis via probabilistic bitflip operators characterized by the readout matrix (also known as confusion matrix) defined over the system of qubits of dimension \\(2^n\\times2^n\\). The complete implementation of the mitigation technique involves using the characterized readout matrix for the system of qubits \\((T)\\) and classically applying an inversion  \\((T^{\u22121})\\) to the measured probability distributions. However there are several limitations of this approach:</p> <ul> <li>The complete implementation requires \\(2^n\\) characterization experiments (probability measurements), which is not scalable.</li> <li>Classical overhead from full matrix inversion for large system of qubits is expensive</li> <li>The matrix \\(T\\) may become singular for large \\(n\\), preventing direct inversion.</li> <li>The inverse \\(T^{\u22121}\\) might not be a stochastic matrix, meaning that it can produce negative corrected probabilities.</li> <li>The correction is not rigorously justified, so we cannot be sure that we are only removing SPAM errors and not otherwise corrupting an estimated probability distribution.</li> </ul> <p>Qadence relies on the assumption of uncorrelated readout errors, this gives us:</p> \\[ T=T_1\\otimes T_2\\otimes \\dots \\otimes T_n \\] <p>for which the inversion is straightforward:</p> \\[ T^{-1}=T_1^{-1}\\otimes T_2^{-1}\\otimes \\dots \\otimes T_n^{-1} \\] <pre><code>from qadence import QuantumModel, QuantumCircuit, hamiltonian_factory, kron, H, Z, I\nfrom qadence import NoiseProtocol, NoiseHandler\n\n\n# Simple circuit and observable construction.\nblock = kron(H(0), I(1))\ncircuit = QuantumCircuit(2, block)\nn_shots = 10000\n\n# Construct a quantum model and noise\nmodel = QuantumModel(circuit=circuit)\nerror_probability = 0.2\nnoise = NoiseHandler(protocol=NoiseProtocol.READOUT.INDEPENDENT,options={\"error_probability\": error_probability})\n\nnoiseless_samples = model.sample(n_shots=n_shots)\nnoisy_samples = model.sample(noise=noise, n_shots=n_shots)\n</code></pre> <pre><code>noiseless samples: [OrderedCounter({'00': 5055, '10': 4945})]\nnoisy samples: [Counter({'10': 4032, '00': 3984, '11': 1002, '01': 982})]\n</code></pre> <p>Note that the noisy states have samples with the second qubit flipped. In the below protocols, we describe ways to reconstruct the noiseless distribution (untargeted mitigation). Besides this one might just be interrested in mitigating the expectation value (targeted mitigation).</p>"},{"location":"error_mitigation/readout_mitigation/#constrained-optimization","title":"Constrained optimization","text":"<p>However, even for a reduced \\(n\\) the forth limitation holds. This can be avoided by reformulating into a minimization problem<sup>1</sup>:</p> \\[ \\lVert Tp_{\\textrm{corr}}-p_{\\textrm{raw}}\\rVert_{2}^{2} \\] <p>subjected to physicality constraints \\(0 \\leq p_{corr}(x) \\leq 1\\) and \\(\\lVert p_{corr} \\rVert = 1\\). At this point, two methods are implemented to solve this problem. The method involves solving a constrained optimization problem and can be computationally expensive.</p> <pre><code>from qadence_protocols.mitigations.protocols import Mitigations\nfrom qadence_protocols.types import ReadOutOptimization\n\n\n# Define the mitigation method solving the minimization problem:\noptions={\"optimization_type\": ReadOutOptimization.CONSTRAINED, \"n_shots\": n_shots}\nmitigation = Mitigations(protocol=Mitigations.READOUT, options=options)\n\n# Run noiseless, noisy and mitigated simulations.\nmitigated_samples_opt = mitigation(model=model, noise=noise)\n</code></pre> <pre><code>Optimization based mitigation: [Counter({'10': 4452, '00': 4326, '01': 659, '11': 563})]\n</code></pre>"},{"location":"error_mitigation/readout_mitigation/#maximum-likelihood-estimation-mle","title":"Maximum Likelihood estimation (MLE)","text":"<p>This method replaces the constraints with additional post processing for correcting probability distributions with negative entries. The runtime of the method is linear in the size of the distribution and thus is very efficient. The optimality of the solution is however not always guaranteed. The method redistributes any negative probabilities on using the inverse operation equally and can be shown to maximize the likelihood with minimal effort<sup>2</sup>.</p> <pre><code># Define the mitigation method solving the minimization problem:\noptions={\"optimization_type\": ReadOutOptimization.MLE, \"n_shots\": n_shots}\nmitigation = Mitigations(protocol=Mitigations.READOUT, options=options)\nmitigated_samples_mle = mitigation(model=model, noise=noise)\n</code></pre> <pre><code>MLE based mitigation [Counter({'10': 4373, '00': 4355, '11': 649, '01': 623})]\n</code></pre>"},{"location":"error_mitigation/readout_mitigation/#matrix-free-measurement-mitigation-mthree","title":"Matrix free measurement mitigation (MTHREE)","text":"<p>This method relies on inverting the probability distribution within a restricted subspace of measured bitstrings<sup>3</sup>. The method is better suited for computations that exceed 20 qubits where the corrected probability distribution would require a state in a unreasonably high dimensional Hilbert space. Thus, the idea here is to stick to the basis states that show up in the measurement alone. Additionally, one might want to include states that are \\(k\\) hamming distance away from it.</p> <pre><code>import numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.linalg import gmres\n\nn_qubits = 10\nexact_prob = np.random.rand(2 ** (n_qubits))\nexact_prob[2 ** (n_qubits//2):]=0\nexact_prob = 0.90 * exact_prob + 0.1 * np.ones(2**n_qubits) / 2**n_qubits\nexact_prob = exact_prob / sum(exact_prob)\nnp.random.shuffle(exact_prob)\n\nobserved_prob = np.array(exact_prob, copy=True)\nobserved_prob[exact_prob &lt; 1 / 2 ** (n_qubits)] = 0\n\nobserved_prob = observed_prob / sum(observed_prob)\n\ninput_csr = csr_matrix(observed_prob, shape=(1, 2**n_qubits)).T\n</code></pre> <pre><code>{'0000010101': 0.025, '0000011001': 0.053, '0001001110': 0.06, '0010001100': 0.065, '0010011001': 0.041, '0010110101': 0.011, '0010111010': 0.046, '0100000110': 0.021, '0100010001': 0.026, '0100101110': 0.009, '0101110100': 0.024, '0110000010': 0.007, '0110111110': 0.053, '0111110001': 0.011, '0111111011': 0.036, '1000000100': 0.045, '1000000101': 0.023, '1000010010': 0.053, '1000010011': 0.002, '1000110111': 0.033, '1000111010': 0.026, '1001010010': 0.06, '1001010100': 0.047, '1001100011': 0.016, '1001100100': 0.007, '1001101110': 0.041, '1001110000': 0.005, '1010001111': 0.066, '1110110001': 0.035, '1111001001': 0.048}\nFilling percentage 0.029296875 %\n</code></pre> <p>We have generated a probability distribution within a small subspace of bitstrings being filled. We use <code>csr_matrix</code> for efficient representation and computation. Now we use MTHREE to do mitigation on the probability distribution</p> <pre><code>from scipy.stats import wasserstein_distance\nfrom qadence_protocols.mitigations.readout import (\n    normalized_subspace_kron,\n    mle_solve,\n    matrix_inv,\n    tensor_rank_mult\n    )\n\nnoise_matrices = []\nfor t in range(n_qubits):\n    t_a, t_b = np.random.rand(2) / 8\n    K = np.array([[1 - t_a, t_a], [t_b, 1 - t_b]]).transpose()  # column sum be 1\n    noise_matrices.append(K)\n\nconfusion_matrix_subspace = normalized_subspace_kron(noise_matrices, observed_prob.nonzero()[0])\n\np_corr_mthree_gmres = gmres(confusion_matrix_subspace, input_csr.toarray())[0]\np_corr_mthree_gmres_mle = mle_solve(p_corr_mthree_gmres)\n\nnoise_matrices_inv = list(map(matrix_inv, noise_matrices))\np_corr_inv_mle = mle_solve(tensor_rank_mult(noise_matrices_inv, observed_prob))\n\ndistance = wasserstein_distance(p_corr_mthree_gmres_mle, p_corr_inv_mle)\n</code></pre> <pre><code>Wasserstein distance between the 2 distributions: 0.00032044566320460634\n</code></pre> <p>We have used <code>wasserstein_distance</code> instead of <code>kl_divergence</code> as many of the bistrings have 0 probabilites. If the expected solution lies outside the space of observed bitstrings, <code>MTHREE</code> will fail. We next look at majority voting to circument this problem when the expected output is a single bitstring.</p>"},{"location":"error_mitigation/readout_mitigation/#majority-voting","title":"Majority Voting","text":"<p>Mitigation protocol to be used only when the circuit output has a single expected bitstring as the solution <sup>4</sup>. The method votes on the likeliness of each qubit to be a 0 or 1 assuming a tensor product structure for the output. The method is valid only when the readout errors are not correlated.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit,kron, H, Z, I\nfrom qadence import NoiseHandler, NoiseProtocol\nfrom qadence_protocols.mitigations.readout import majority_vote\nimport numpy as np\n\n# Simple circuit and observable construction.\nn_qubits = 4\nblock = kron(*[I(i) for i in range(n_qubits)])\ncircuit = QuantumCircuit(n_qubits, block)\nn_shots = 1000\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit)\n\n# Sampling the noisy solution\nerror_p = 0.2\nnoise = NoiseHandler(protocol=NoiseProtocol.READOUT.INDEPENDENT,options={\"error_probability\": error_p})\nnoisy_samples = model.sample(noise=noise, n_shots=n_shots)[0]\n\n# Removing samples that correspond to actual solution\nnoisy_samples['0000'] = 0\n\n# Constructing the probability vector\nordered_bitstrings = [bin(k)[2:].zfill(n_qubits) for k in range(2**n_qubits)]\nobserved_prob = np.array([noisy_samples[bs] for bs in ordered_bitstrings]) / n_shots\n</code></pre> <pre><code>noisy samples: Counter({'1000': 112, '0001': 103, '0100': 102, '0010': 92, '1001': 32, '1100': 31, '0011': 26, '0101': 26, '0110': 26, '1010': 24, '0111': 7, '1101': 6, '1110': 4, '1011': 4, '1111': 2, '0000': 0})\nobserved probability: [0.    0.103 0.092 0.026 0.102 0.026 0.026 0.007 0.112 0.032 0.024 0.004\n 0.031 0.006 0.004 0.002]\n</code></pre> <p>We have removed the actual solution from the observed distribution and will use this as the observed probability.</p> <pre><code>noise_matrices = [np.array([[1 - error_p, error_p], [error_p, 1 - error_p]])]*n_qubits\nresult_index = majority_vote(noise_matrices, observed_prob).argmax()\n</code></pre> <pre><code>mitigated solution index: 0\n</code></pre>"},{"location":"error_mitigation/readout_mitigation/#model-free-mitigation","title":"Model free mitigation","text":"<p>This protocol makes use of all possible so-called twirl operations to average out the effect of readout errors into an effective scaling. The twirl operation consists of using bit flip operators before the measurement and after the measurement is obtained<sup>5</sup>. The number of twirl operations can be reduced through random sampling. The method is exact in that it requires no calibration which might be prone to errors of modelling.</p> <pre><code>from qadence import NoiseHandler, NoiseProtocol\nfrom qadence.measurements import Measurements\nfrom qadence.operations import CNOT, RX, Z\nfrom qadence_protocols import Mitigations\n\nimport torch\nfrom qadence import (\n    QuantumCircuit,\n    QuantumModel,\n    chain,\n    kron,\n)\n\nerror_probability=0.15\nn_shots=10000\nblock= chain(kron(RX(0, torch.pi / 3), RX(1, torch.pi / 6)), CNOT(0, 1))\nobservable=[3 * kron(Z(0), Z(1)) + 2 * Z(0)]\n\ncircuit = QuantumCircuit(block.n_qubits, block)\nnoise = NoiseHandler(protocol=NoiseProtocol.READOUT.INDEPENDENT, options={\"error_probability\": error_probability})\ntomo_measurement = Measurements(\n    protocol=Measurements.TOMOGRAPHY,\n    options={\"n_shots\": n_shots},\n)\n\nmodel = QuantumModel(\n    circuit=circuit, observable=observable,\n)\n\nnoisy_model = QuantumModel(\n    circuit=circuit,\n    observable=observable,\n    measurement=tomo_measurement,\n    noise=noise,\n)\n\nmitigate = Mitigations(protocol=Mitigations.TWIRL)\nexpectation_mitigated = mitigate(noisy_model)\n</code></pre> <pre><code>noiseless expectation value tensor([[3.5642]], grad_fn=&lt;TransposeBackward0&gt;)\nnoisy expectation value tensor([[2.0080]], grad_fn=&lt;TransposeBackward0&gt;)\nexpected mitigation value tensor([3.5358])\n</code></pre>"},{"location":"error_mitigation/readout_mitigation/#references","title":"References","text":"<ol> <li> <p>Michael R. Geller and Mingyu Sun, Efficient correction of multiqubit measurement errors, (2020) \u21a9</p> </li> <li> <p>Smolin et al., Maximum Likelihood, Minimum Effort, (2011) \u21a9</p> </li> <li> <p>Gambetta et al.: Scalable mitigation of measurement errors on quantum computers \u21a9</p> </li> <li> <p>Dror Baron et al.: Maximum Likelihood Quantum Error Mitigation for Algorithms with a Single Correct Output \u21a9</p> </li> <li> <p>Kristan Temme et al. : Model-free readout-error mitigation for quantum expectation values  \u21a9</p> </li> </ol>"},{"location":"measurements/","title":"Measurements Protocols","text":"<p>Sample-based measurement protocols are fundamental tools for the prediction and estimation of a quantum state as the result of NISQ programs executions. Their resource efficient implementation is a current and active research field. Currently, quantum state tomography is implemented in qadence-protocols.</p>"},{"location":"measurements/#quantum-state-tomography","title":"Quantum state tomography","text":"<p>The fundamental task of quantum state tomography is to learn an approximate classical description of an output quantum state described by a density matrix \\(\\rho\\), from repeated measurements of copies on a chosen basis. To do so, \\(\\rho\\) is expanded in a basis of observables (the tomography step) and for a given observable \\(\\hat{\\mathcal{O}}\\), the expectation value is calculated with \\(\\langle \\hat{\\mathcal{O}} \\rangle=\\textrm{Tr}(\\hat{\\mathcal{O}}\\rho)\\). A number of measurement repetitions in a suitable basis is then required to estimate \\(\\langle \\hat{\\mathcal{O}} \\rangle\\).</p> <p>The main drawback is the scaling in measurements for the retrieval of the classical expression for a \\(n\\)-qubit quantum state as \\(2^n \\times 2^n\\), together with a large amount of classical post-processing.</p> <p>For an observable expressed as a Pauli string \\(\\hat{\\mathcal{P}}\\), the expectation value for a state \\(|\\psi \\rangle\\) can be derived as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\langle \\psi | \\hat{\\mathcal{P}} |\\psi \\rangle=\\langle \\psi | \\hat{\\mathcal{R}}^\\dagger \\hat{\\mathcal{D}} \\hat{\\mathcal{R}} |\\psi \\rangle \\] <p>The operator \\(\\hat{\\mathcal{R}}\\) diagonalizes \\(\\hat{\\mathcal{P}}\\) and rotates the state into an eigenstate in the computational basis. Therefore, \\(\\hat{\\mathcal{R}}|\\psi \\rangle=\\sum\\limits_{z}a_z|z\\rangle\\) and the expectation value can finally be expressed as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\sum_{z,z'}\\langle z |\\bar{a}_z\\hat{\\mathcal{D}}a_{z'}|z'\\rangle = \\sum_{z}|a_z|^2(-1)^{\\phi_z(\\hat{\\mathcal{P}})} \\] <p>In Qadence, running a tomographical experiment is made simple by defining a <code>Measurements</code> object that captures all options for execution:</p> <pre><code>from torch import tensor\nfrom qadence import hamiltonian_factory, BackendName, DiffMode, NoiseHandler\nfrom qadence import chain, kron, X, Z, QuantumCircuit, QuantumModel\nfrom qadence_protocols import Measurements, MeasurementProtocol\n\nblocks = chain(\n    kron(X(0), X(1)),\n    kron(Z(0), Z(1)),\n)\n\n# Create a circuit and an observable.\ncircuit = QuantumCircuit(2, blocks)\nobservable = hamiltonian_factory(2, detuning=Z)\n\n# Create a model.\nmodel = QuantumModel(\n    circuit=circuit,\n    observable=observable,\n    backend=BackendName.PYQTORCH,\n    diff_mode=DiffMode.GPSR,\n)\n\n# Define a measurement protocol by passing the shot budget as an option.\ntomo_options = {\"n_shots\": 100000}\ntomo_measurement = Measurements(protocol=MeasurementProtocol.TOMOGRAPHY, options=tomo_options)\n\n# Get the exact expectation value.\nexact_values = model.expectation()\n\n# Run the tomography experiment.\nestimated_values_tomo = tomo_measurement(model=model)\n</code></pre> <pre><code>Exact expectation value = tensor([[-2.]])\nEstimated expectation value tomo = tensor([[-2.]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"measurements/#getting-measurements","title":"Getting measurements","text":"<p>If we are interested in accessing the measurements for computing different quantities of interest other than the expectation values, we can access the measurement data via <code>data</code> as follows:</p> <pre><code>measurements_tomo = tomo_measurement.data\n</code></pre> <pre><code>MeasurementData(samples=[[[OrderedCounter({'11': 100000})], [OrderedCounter({'11': 100000})]]], unitaries=tensor([]))\n</code></pre>"},{"location":"measurements/#classical-shadows","title":"Classical shadows","text":"<p>A much less resource demanding protocol based on classical shadows has been proposed<sup>1</sup>. It combines ideas from shadow tomography<sup>2</sup> and randomized measurement protocols <sup>3</sup> capable of learning a classical shadow of an unknown quantum state \\(\\rho\\). It relies on deliberately discarding the full classical characterization of the quantum state, and instead focuses on accurately predicting a restricted set of properties that provide efficient resources for the study of the system.</p> <p>A random measurement consists of applying random unitary rotations before a fixed measurement on each copy of a state. Appropriately averaging over these measurements produces an efficient estimator for the expectation value of an observable. This protocol therefore creates a robust classical representation of the quantum state or classical shadow. The captured measurement information is then reuseable for multiple purposes, i.e. any observable expected value and available for noise mitigation postprocessing.</p> <p>A classical shadow is therefore an unbiased estimator of a quantum state \\(\\rho\\). Such an estimator is obtained with the following procedure<sup>1</sup>: first, apply a random unitary gate \\(U\\) to rotate the state: \\(\\rho \\rightarrow U \\rho U^\\dagger\\) and then perform a basis measurement to obtain a \\(n\\)-bit measurement \\(|\\hat{b}\\rangle \\in \\{0, 1\\}^n\\). Both unitary gates \\(U\\) and the measurement outcomes \\(|\\hat{b}\\rangle\\) are stored on a classical computer for postprocessing v \\(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U\\), a classical snapshot of the state \\(\\rho\\). The whole procedure can be seen as a quantum channel \\(\\mathcal{M}\\) that maps the initial unknown quantum state \\(\\rho\\) to the average result of the measurement protocol:</p> \\[ \\mathbb{E}[U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U] = \\mathcal{M}(\\rho) \\Rightarrow \\rho = \\mathbb{E}[\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)] \\] <p>It is worth noting that the single classical snapshot \\(\\hat{\\rho}=\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)\\) equals \\(\\rho\\) in expectation: \\(\\mathbb{E}[\\hat{\\rho}]=\\rho\\) despite \\(\\mathcal{M}^{-1}\\) not being a completely positive map. Repeating this procedure \\(N\\) times results in an array of \\(N\\) independent, classical snapshots of \\(\\rho\\) called the classical shadow:</p> \\[ S(\\rho, N) = \\{ \\hat{\\rho}_1=\\mathcal{M}^{-1}(U_1^\\dagger |\\hat{b}_1\\rangle\\langle \\hat{b}_1|U_1),\\cdots,\\hat{\\rho}_N=\\mathcal{M}^{-1}(U_N^\\dagger |\\hat{b}_N\\rangle\\langle \\hat{b}_N|U_N)\\} \\] <p>Along the same lines as the example before, estimating the expectation value using classical shadows in Qadence only requires to pass the right set of parameters to the <code>Measurements</code> object:</p> <pre><code># Classical shadows are defined up to some accuracy and confidence.\nfrom qadence_protocols.measurements.utils_shadow import number_of_samples\n\nshadow_options = {\"accuracy\": 0.1, \"confidence\": 0.1}\nN, K = number_of_samples(observable, **shadow_options)\nshadow_measurement = Measurements(protocol=MeasurementProtocol.SHADOW, options=shadow_options)\n\n# Run the shadow experiment.\nestimated_values_shadow = shadow_measurement(model=model)\n</code></pre> <pre><code>Estimated expectation value shadow = tensor([[-2.]])\n</code></pre>"},{"location":"measurements/#getting-shadows","title":"Getting shadows","text":"<p>If we are interested in accessing the measurement data from shadows, we can access the measurement data via the <code>manager</code> attribute as follows:</p> <pre><code>measurements_shadows = shadow_measurement.data\n</code></pre> <pre><code>Sampled unitary indices shape:  torch.Size([10200, 2])\nShape of batched measurements:  torch.Size([1, 10200, 2])\n</code></pre> <p>In the case of shadows, the measurement data is composed of two elements: - <code>unitaries</code> refers to the indices corresponding to the randomly sampled Pauli unitaries \\(U\\). It is returned as a tensor of shape (shadow_size, n_qubits). Its elements are integer values 0, 1, 2 corresponding respectively to X, Y, Z. - the second one, <code>samples</code>, refers to the bistrings obtained by measurements of the circuit rotated depending on the sampled Pauli basis. It as returned as a tensor of batched measurements with shape (batch_size, shadow_size, n_qubits).</p> <p>Such a measurement data can be used directly for computing different quantities of interest other than the expectation values. For instance, we can do state reconstruction and use it to calculate another expectation value as follows:</p> <pre><code># reconstruct state from snapshots\nstate = shadow_measurement.reconstruct_state()\n\n# calculate expectations\nfrom qadence_protocols.utils_trace import expectation_trace\nexp_reconstructed_state = expectation_trace(state, observable)\n</code></pre> <pre><code>tensor([[-2.0262]])\n</code></pre>"},{"location":"measurements/#robust-shadows","title":"Robust shadows","text":"<p>Robust shadows <sup>4</sup> were built upon the classical shadow scheme but have the particularity to be noise-resilient. Using an experimentally friendly calibration procedure, one can e\ufb03ciently characterize and mitigate noises in the shadow estimation scheme, given only minimal assumptions on the experimental conditions. Such a procedure has been used in <sup>5</sup> to estimate the Quantum Fisher information out of a quantum system. Note that robust shadows are equivalent to classical shadows in non-noisy settings by setting the <code>calibration</code> coefficients to \\(\\frac{1}{3}\\) for each qubit.</p> <pre><code>from qadence import NoiseProtocol, NoiseHandler\nfrom qadence_protocols.measurements.calibration import zero_state_calibration\n\nerror_probability = 0.1\nnoise = NoiseHandler(protocol=NoiseProtocol.READOUT.INDEPENDENT, options={\"error_probability\": error_probability})\n\nmodel = QuantumModel(\n    circuit=circuit,\n    observable=observable,\n    backend=BackendName.PYQTORCH,\n    diff_mode=DiffMode.GPSR,\n    noise=noise\n)\nexact_values = model.expectation()\n\ncalibration = zero_state_calibration(N, n_qubits=2, n_shots=100, backend=model.backend, noise=noise)\n# This linear transformation should give us the probability error\n\nrobust_shadow_options = {\"shadow_size\": N, \"shadow_medians\": K, \"calibration\": calibration}\nrobust_shadow_measurement = Measurements(protocol=MeasurementProtocol.ROBUST_SHADOW, options=robust_shadow_options)\nestimated_values_robust_shadow = robust_shadow_measurement(model=model)\n</code></pre> <pre><code>tensor([0.9003, 0.9000])\nEstimated expectation value shadow = tensor([[-1.2686]])\n</code></pre>"},{"location":"measurements/#references","title":"References","text":"<ol> <li> <p>Hsin-Yuan Huang, Richard Kueng and John Preskill, Predicting Many Properties of a Quantum System from Very Few Measurements (2020) \u21a9\u21a9</p> </li> <li> <p>S. Aaronson. Shadow tomography of quantum states. In Proceedings of the 50th Annual A ACM SIGACT Symposium on Theory of Computing, STOC 2018, pages 325\u2013338, New York, NY, USA, 2018. ACM\u00a0\u21a9</p> </li> <li> <p>Aniket Rath. Probing entanglement on quantum platforms using randomized measurements. Physics [physics]. Universit\u00e9 Grenoble Alpes [2020-..], 2023. English. ffNNT : 2023GRALY072ff. fftel-04523142\u00a0\u21a9</p> </li> <li> <p>Senrui Chen, Wenjun Yu, Pei Zeng, and Steven T. Flammia, Robust Shadow Estimation (2021) \u21a9</p> </li> <li> <p>Vittorio Vitale, Aniket Rath, Petar Jurcevic, Andreas Elben, Cyril Branciard, and Beno\u00eet Vermersch, Robust Estimation of the Quantum Fisher Information on a Quantum Processor (2024) \u21a9</p> </li> </ol>"}]}